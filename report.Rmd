---
title: 'Florence Nightingale Competition 2020 - RLadies Spain'
author: "Authors: Laura Ventosa & Esther Manzano"
date: "July 2020"
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
  pdf_document:
    highlight: zenburn
    toc: yes
  word_document: default
---
```{r setup, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
``` 


*****
Index (deixant-ho així report en html es veu malament però deixem-ho per saber els apartats a introduir més a sota)
*****

1. Variables analysis
  
2. Plots

3. Regressions

4. Predictions

5. Conclusions


*****
# Variables analysis
*****

Alguns punts extres?

Faltarà també comentar cada tros d'output que aparegui en el report passat a html, així com també afegir comentaris per que quedi tot el codi clar

We check the different types of data on our dataset. The aim is to understand the nature of our variables (i.e. the proportion of numerical and categorical variables) to be able to develope a better model afterwards. Checks on missing values and outliers will be performed in addition.

```{r}
rm(list=ls()) #Per esborrar tot el que estigui carregat d'algun environment que haguem tingut anteriorment (podem esborrar-ho un cop ho entreguem però jo sempre ho deixo just in case)

#Libraries used across the whole project:     (haurem de revisar quins no fem servir al final i treure'ls)
library(readxl)
library(tidyverse)
library(gt)
library(dygraphs)
library(xts) 
library(lmtest)
library(sandwich)
library(ResourceSelection)
library(pROC)

#Importing dataset:
data <- read_excel("../nightingale-competition/datos_florence.xlsx", skip=1)

#Making everything more readable and column names more manageable:
colnames(data)[1] <- "month"
colnames(data)[2] <- "avg_size_army"
colnames(data)[3] <- "zymotic"
colnames(data)[4] <- "injuries"
colnames(data)[5] <- "other"
colnames(data)[6] <- "zymotic_rate"
colnames(data)[7] <- "injuries_rate"
colnames(data)[8] <- "other_rate"
```

The following table shows the first rows of our dataset, including the names of the variables we have worked with.
```{r}
#Basic information:
head(data)
```
```{r}
#Dimensions of the dataset:
dim(data)
```
```{r}
#Variables:
sapply(data, class)
```
```{r}
summary(data)
```
As the periods in our dataset are prior to January 1900, R cannot handle them as proper dates. For this reason, we are going to treat time as a numerical variable taking integer value from 0 to 23 in chronological order. This table of equivalences may be useful for the interpretation of the results in this report.

```{r}
#Creating a numeric variable to account for time period:
L <- nrow(data)
time_period <- seq(0,(L-1)) #Podríem passar-ho de 1 a L
data$time_period <- time_period
#data <- as.data.frame(data)
time_vars <- select(data, month, time_period)
time_vars %>% 
  gt() %>%
    tab_header(title = md("**Time periods**"), subtitle = md("Equivalence between both variables"))
#He intentat fer-la més maca però el meu coneixement de taules és limitat. Trobo que queda potser una mica estreta però altres dissenys tampoc m'han acabat de fer el pes
```
```{r}
#Adding new variables to the dataset:
deaths <- vector() 
for(i in 1:L){
  deaths[i] <- data$zymotic[i] + data$injuries[i] + data$other[i]
}
data$total_deaths <- deaths #Agreggated deaths (all causes) per month

cum_deaths <- vector()
cum_deaths <- cumsum(deaths)
data$cum_deaths <- cum_deaths #Cumulative deaths over time
```
```{r}
deaths_evol <- select(data, month, total_deaths, time_period)
ordered_deaths <- deaths_evol %>% 
  arrange(desc(deaths_evol$total_deaths)) #Months arranged from higher to lower number of deaths

ordered_deaths %>% 
  gt() %>%
    tab_header(title = md("**Total deaths by month**"), subtitle = md("Data sorted in descending order"))
#Again, no sé fer la taula més mona jajajaja
```
The above table shows our dataset but sorted by the number of total deaths in descending order. We can observe that
the time period with the highest number of deaths is January 1855, the 10th time period in chronological order. Not surprisingly, April 1854, the first period in our dataset, is the one with the fewest deaths.

```{r}
#Checking missing values:
colSums(is.na(data)) 
```
As we can see, there are no NA values in our dataset.

```{r}
#Checking outliers:
boxplot(data$injuries, col="lightgoldenrod", main="Deaths by injuries")
boxplot(data$zymotic, col="mistyrose", main="Deaths by zymotic disease")
boxplot(data$other, col="powderblue", main="Deaths by other causes")
#He intentat encabir les tres caixes en un sol plot però no he aconseguit que quedessin quadrades les labels a l'eix horitzontal amb el nom de cada variable. Provar de fer-ho!
```

*****
# Plots
*****

 --> (Afegim plots amb Shiny) i comentem els gràfics. Què s'hi pot veure? Quins conclusions en treiem?

```{r}
#Millor fer servir time_period però transformant la data amb xts() queda l'eix x amb dates al gràfic dinàmic. Provar-ho!
# Podem provar amb altres tipus de gràfic a veure com queda. Si és redundant, els treiem i deixem els que tenim fins ara.
data_plot_1 <- data.frame(
  Time=data$time_period, 
  Zymotic=data$zymotic, 
  Injuries=data$injuries,
  Other=data$other)
dygraph(data_plot_1, main="Death causes (absolute values)")
```
```{r}
data_plot_2 <- data.frame(
  Time=data$time_period,
  Zymotic=data$zymotic_rate, 
  Injuries=data$injuries_rate,
  Other=data$other_rate)
dygraph(data_plot_2, main="Death causes (rates)")
```
```{r}
data_plot_3 <- data.frame(
  Time=data$time_period,
  Army=data$avg_size_army)
dygraph(data_plot_3, main="Average size of the army")
```
```{r}
data_plot_4 <- data.frame(
  Time=data$time_period,
  Accumulated_deaths=cum_deaths) #No m'acaba d'agradar el nom de la variable top-right. Millor data amb xts()?
dygraph(data_plot_4, main="Accumulated number of deaths")
```

*****
# Regressions
*****

Fer regresio de les causes per separat i analisi amb grafics.
(Deixem tots deaths model)
Fer regresio multivariant amb totes les deaths juntes

```{r}
#Analysis of correlations per different types of deaths segregated: (mirar com ho deixem)
cor(data$avg_size_army, data$zymotic)  
cor(data$avg_size_army, data$injuries)
cor(data$avg_size_army, data$other)
```
```{r}
#Multivariant linear regresion between all deaths (segregated) and the average size of army:
mod2 <- lm(avg_size_army ~ data$zymotic+data$injuries+data$other, data=data)
summary(mod2)

#Amb Newey-West per tenir en compte l'autocorrelació:
coeftest(mod2,NeweyWest(mod2))
```
Comentem que totes son negatives excepte una. Les morts d'aquesta causa van fer que reclutessin més soldats?

```{r}
#Univariant linear regresion between all deaths and the average size of army:
mod1 <- lm(avg_size_army ~ total_deaths, data=data)
summary(mod1)

#Amb Newey-West per tenir en compte l'autocorrelació:
coeftest(mod1,NeweyWest(mod1))
```
```{r}
#Analysis of correlation for all deaths:
cor(data$avg_size_army, data$total_deaths)

#Valor absolut entre 0 i 1? Com més properes a 1 en valor absolut més correlacionades estan.
```
Dades dels soldats nous que entraven? Com afectava que morissin i entressin soldats nous?
Aquestes dues variables no estan correlacionades.
Comentem que no tenen relació. Possibles raons de perquè no tenen correlació. Info que podria faltar i no tenim?

```{r}
tra_death <- data.frame(y=data$total_deaths[2:L], lag1=data$total_deaths[1:(L-1)]) 
reg1 <- lm(y ~ lag1, data=tra_death) #Regressió morts avui en funció de les morts d'ahir
summary(reg1)

#Amb Newey-West per tenir en compte l'autocorrelació:
coeftest(reg1,NeweyWest(reg1))

#Les morts d'ahir tenen efecte sobre les morts d'avui.
```


```{r}
reg2 <- lm(data$total_deaths ~ data$time_period, data=data)
summary(reg2) #No significació del time period sobre total deaths
```

Seasonality: mirar si hi ha algun time period que té mñés significació que alguna altra!
Timeseries o forecast llibreries!

```{r}
# Diagnosi dels models: --> Pen so que potser hauriem d'escollir el model que funciona millor/té més correlació i fer-ho sobre aquest!
residual.values <- rstandard(reg1) 
adjusted.values <- fitted(reg1) 
plot(adjusted.values, residual.values, main="Residual plot reg1 (canviar nom maybe)", ylab="Residual Values", xlab="Adjusted Values", col="lightsalmon3", abline(0, 0), pch=19)
#He afegit colors al gràfic, poden ser aquests o es poden canviar. Podríem utilitzar els mateixos colors per tots els plots d'un mateix tipus
# Fer diagnosi del model per totes els models i comentar.
```
```{r}
qqnorm(residual.values, col="blue")
qqline(residual.values)

#A la vista del gràfic, no s’observa cap patró especial, de manera que tant la homocedasticitat com la linealitat resulten hipòtesis raonables.
#D’altra banda, el Q_Q plot mostra que les dades no s’ajusten bé a una normal.
```
Queden més amunt o més avall en un costat o en un altre? Com a quin costat és més asimètrica?
Per revisar!

```{r}
reg3 <- lm(formula=data$avg_size_army~data$injuries, data=data) 
summary(reg3)
```


Provem amb regressions logistiques?


*****
# Predictions
*****

```{r}
#Accuracy de reg1 per fer prediccions (he provat de fer la del número de morts basant-me només en un lag d'aquesta mateixa variable per provar de fer-ne alguna)
train_data <- subset(data, time_period<=round(0.7*L)) #70% training data
test_data <- subset(data, time_period>round(0.7*L)) #30% test/validation data
training1 <- data.frame(y=train_data$total_deaths, lag1=train_data$total_deaths) 
model1 <- lm(y ~ lag1, data=training1)
y.hat1 <- predict(model1, data=test_data)
error1 <- abs(y.hat1 - test_data$total_deaths)
rmse1 <- sqrt((sum(error1)**2)/nrow(test_data)) 
#Fatal performance, tampoc sé si té gaire sentit predir el número de morts futures a partir de les del dia anterior, ens caldria algo amb més chicha
```
```{r}
# Ho hem de fer amb un model que funcioni però... Quina seria la probabilitat de X si Y és això i Z és això altre?
#pred<-predict(reg1, data.frame(Y="1",Z=90),type = "response")
#pred
```
```{r}
# Calculem la bondat de l'ajust: <- s'ha de tocar la data
#hoslem.test(X,fitted(modelX))
```
```{r}
# Dibuixem la corba ROC: <- s'ha de tocar la data
#prob_low=predict(logit_model_2, datA3, type="response")
#r=roc(BW_RE,prob_low, data=datA3)
```

*****
# Conclusions
*****