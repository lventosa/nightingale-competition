# Correlations (mirar com ho deixem)
cor(data$avg_size_army, data$zymotic)
cor(data$avg_size_army, data$injuries)
cor(data$avg_size_army, data$other)
cor(data$avg_size_army, data$total_deaths)
tra_death <- data.frame(y=data$total_deaths[2:L], lag1=data$total_deaths[1:(L-1)])
reg1 <- lm(y ~ lag1, data=tra_death) #Regressió morts avui en funció de les morts d'ahir
summary(reg1)
mod1 <- lm(deaths ~ avg_size_army, data=data) #Regressió morts avui en funció de les morts d'ahir
summary(mod1)
#Univariant linear regresion between all deaths and the average size of army:
mod1 <- lm(avg_size_army ~ deaths, data=data)
summary(mod1)
data$zymotic
zymotic
#Multivariant linear regresion between all deaths (segregated) and the average size of army:
mod2 <- lm(avg_size_army ~ data$zymotic+data$injuries+data$other, data=data)
summary(mod2)
data$total_deaths
#Analysis of correlation for all deaths:
cor(data$avg_size_army, data$total_deaths)
#És deaths i totaldeaths el mateix?
#Multivariant linear regresion between all deaths (segregated) and the average size of army:
mod2 <- lm(avg_size_army ~ data$zymotic+data$injuries+data$other, data=data)
summary(mod2)
#Analysis of correlations per different types of deaths segregated: (mirar com ho deixem)
cor(data$avg_size_army, data$zymotic)
cor(data$avg_size_army, data$injuries)
cor(data$avg_size_army, data$other)
tra_death <- data.frame(y=data$total_deaths[2:L], lag1=data$total_deaths[1:(L-1)])
reg1 <- lm(y ~ lag1, data=tra_death) #Regressió morts avui en funció de les morts d'ahir
summary(reg1)
reg2 <- lm(data$total_deaths ~ data$time_period, data=data)
summary(reg2) #No significació del time period sobre total deaths
#Accuracy de reg1 per fer prediccions (he provat de fer la del número de morts basant-me només en un lag d'aquesta mateixa variable per provar de fer-ne alguna)
train_data <- subset(data, time_period<=round(0.7*L)) #70% training data
test_data <- subset(data, time_period>round(0.7*L)) #30% test/validation data
training1 <- data.frame(y=train_data$total_deaths, lag1=train_data$total_deaths)
model1 <- lm(y ~ lag1, data=training1)
y.hat1 <- predict(model1, data=test_data)
error1 <- abs(y.hat1 - test_data$total_deaths)
rmse1 <- sqrt((sum(error1)**2)/nrow(test_data))
#Fatal performance, tampoc sé si té gaire sentit predir el número de morts futures a partir de les del dia anterior, ens caldria algo amb més chicha
# Diagnosi dels models:
residual.values <- rstandard(reg1)
adjusted.values <- fitted(reg1)
plot(adjusted.values, residual.values, main="Residual plot reg1 (canviar nom maybe)", ylab="Residual Values", xlab="Adjusted Values", col="lightsalmon3", abline(0, 0), pch=19)
#He afegit colors al gràfic, poden ser aquests o es poden canviar. Podríem utilitzar els mateixos colors per tots els plots d'un mateix tipus
qqnorm(residual.values) #posar-li colors també
qqline(residual.values)
#A la vista del gràfic, no s’observa cap patró especial, de manera que tant la homocedasticitat com la linealitat resulten hipòtesis raonables.
#D’altra banda, el Q_Q plot mostra que les dades no s’ajusten bé a una normal.
reg3 <- glm(formula=data$avg_size_army~data$injuries, data=data)
summary(reg3)
exp(coefficients(reg3))
exp(confint(reg3))
reg4 <- glm(formula=data$avg_size_army~data$zymotic, data=data)
summary(reg4)
# Diagnosi dels models:
residual.values <- rstandard(reg1)
adjusted.values <- fitted(reg1)
plot(adjusted.values, residual.values, main="Residual plot reg1 (canviar nom maybe)", ylab="Residual Values", xlab="Adjusted Values", col="lightsalmon3", abline(0, 0), pch=19)
#He afegit colors al gràfic, poden ser aquests o es poden canviar. Podríem utilitzar els mateixos colors per tots els plots d'un mateix tipus
qqnorm(residual.values) #posar-li colors també
qqline(residual.values)
ylab="Residual Values", xlab="Adjusted Values", col="lightsalmon3", abline(0, 0), pch=19)
qqnorm(residual.values) #posar-li colors també
qqline(residual.values)
with(plotData, {
plot(x, y, col = ifelse(id == 1, "red", "blue"))
abline(int, slope)
})
qqnorm(residual.values) #posar-li colors també
qqline(residual.values)
plotData <- qqPlot(myData$x, "normal",confbounds = FALSE, col = sample(colors(), nrow(myData)))
qqnorm(residual.values)
qqline(residual.values)
qqnorm(d1$V1[is.finite(d1$V1)], col=colorvector)
qqnorm(residual.values, col=colorvector)
qqnorm(residual.values, col="lightsalmon3")
qqline(residual.values)
qqnorm(d1$V1[is.finite(d1$V1)], col=colorvector)
qqnorm(residual.values, col="blue")
qqline(residual.values)
qqnorm(d1$V1[is.finite(d1$V1)], col=colorvector)
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
#Creating a numeric variable to account for time period:
L <- nrow(data)
time_period <- seq(0,(L-1)) #Podríem passar-ho de 1 a L
data$time_period <- time_period
data <- as.data.frame(data)
#Making everything more readable and column names more manageable:
colnames(data)[1] <- "month"
colnames(data)[2] <- "avg_size_army"
colnames(data)[3] <- "zymotic"
colnames(data)[4] <- "injuries"
colnames(data)[5] <- "other"
colnames(data)[6] <- "zymotic_rate"
colnames(data)[7] <- "injuries_rate"
colnames(data)[8] <- "other_rate"
data$time_period
#Creating a numeric variable to account for time period:
L <- nrow(data)
time_period <- seq(0,(L-1)) #Podríem passar-ho de 1 a L
data$time_period <- time_period
data <- as.data.frame(data)
#Making everything more readable and column names more manageable:
colnames(data)[1] <- "month"
colnames(data)[2] <- "avg_size_army"
colnames(data)[3] <- "zymotic"
colnames(data)[4] <- "injuries"
colnames(data)[5] <- "other"
colnames(data)[6] <- "zymotic_rate"
colnames(data)[7] <- "injuries_rate"
colnames(data)[8] <- "other_rate"
data
#Making everything more readable and column names more manageable:
colnames(data)[1] <- "month"
colnames(data)[2] <- "avg_size_army"
colnames(data)[3] <- "zymotic"
colnames(data)[4] <- "injuries"
colnames(data)[5] <- "other"
colnames(data)[6] <- "zymotic_rate"
colnames(data)[7] <- "injuries_rate"
colnames(data)[8] <- "other_rate"
#Adding new variables to the dataset:
deaths <- vector()
for(i in 1:L){
deaths[i] <- data$zymotic[i] + data$injuries[i] + data$other[i]
}
data$total_deaths <- deaths #Agreggated deaths (all causes) per month
cum_deaths <- vector()
cum_deaths <- cumsum(deaths)
data$cum_deaths <- cum_deaths #Cumulative deaths over time
data %>%
arrange(desc(total_deaths)) #Months arranged from higher to lower number of deaths
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
#Libraries used across the whole project:     (haurem de revisar quins no fem servir al final i treure'ls)
library(readxl)
library(tidyverse)
library(viridis)
library(dygraphs)
library(xts)
library(lmtest)
library(ResourceSelection)
library(pROC)
#Importing dataset:
data <- read_excel("../nightingale-competition/datos_florence.xlsx", skip=1)
#Basic information:
head(data)
#Dimensions of the dataset:
dim(data)
#Variables:
sapply(data, class)
summary(data)
data %>%
arrange(desc(total_deaths)) #Months arranged from higher to lower number of deaths
data$total_deaths
total_deaths
#Making everything more readable and column names more manageable:
colnames(data)[1] <- "month"
colnames(data)[2] <- "avg_size_army"
colnames(data)[3] <- "zymotic"
colnames(data)[4] <- "injuries"
colnames(data)[5] <- "other"
colnames(data)[6] <- "zymotic_rate"
colnames(data)[7] <- "injuries_rate"
colnames(data)[8] <- "other_rate"
#Adding new variables to the dataset:
deaths <- vector()
for(i in 1:L){
deaths[i] <- data$zymotic[i] + data$injuries[i] + data$other[i]
}
data$total_deaths <- deaths #Agreggated deaths (all causes) per month
cum_deaths <- vector()
cum_deaths <- cumsum(deaths)
data$cum_deaths <- cum_deaths #Cumulative deaths over time
data %>%
arrange(desc(total_deaths)) #Months arranged from higher to lower number of deaths
#Checking missing values:
colSums(is.na(data))
#Checking outliers:
boxplot(data$injuries, col="lightgoldenrod", main="Deaths by injuries")
boxplot(data$zymotic, col="mistyrose", main="Deaths by zymotic disease")
boxplot(data$other, col="powderblue", main="Deaths by other causes")
#He intentat encabir les tres caixes en un sol plot però no he aconseguit que quedessin quadrades les labels a l'eix horitzontal amb el nom de cada variable
#Millor fer servir time_period però transformant la data amb xts() queda l'eix x amb dates al gràfic dinàmic
data_plot_1 <- data.frame(
time=data$time_period,
Zymotic=data$zymotic,
Injuries=data$injuries,
Other=data$other)
#Millor fer servir time_period però transformant la data amb xts() queda l'eix x amb dates al gràfic dinàmic
data_plot_1 <- data.frame(
time=data$time_period,
Zymotic=data$zymotic,
Injuries=data$injuries,
Other=data$other)
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
#Libraries used across the whole project:     (haurem de revisar quins no fem servir al final i treure'ls)
library(readxl)
library(tidyverse)
library(viridis)
library(dygraphs)
library(xts)
library(lmtest)
library(ResourceSelection)
library(pROC)
#Importing dataset:
data <- read_excel("../nightingale-competition/datos_florence.xlsx", skip=1)
#Basic information:
head(data)
#Dimensions of the dataset:
dim(data)
#Variables:
sapply(data, class)
summary(data)
#Creating a numeric variable to account for time period:
L <- nrow(data)
time_period <- seq(0,(L-1)) #Podríem passar-ho de 1 a L
data$time_period <- time_period
data <- as.data.frame(data)
#Making everything more readable and column names more manageable:
colnames(data)[1] <- "month"
colnames(data)[2] <- "avg_size_army"
colnames(data)[3] <- "zymotic"
colnames(data)[4] <- "injuries"
colnames(data)[5] <- "other"
colnames(data)[6] <- "zymotic_rate"
colnames(data)[7] <- "injuries_rate"
colnames(data)[8] <- "other_rate"
#Adding new variables to the dataset:
deaths <- vector()
for(i in 1:L){
deaths[i] <- data$zymotic[i] + data$injuries[i] + data$other[i]
}
data$total_deaths <- deaths #Agreggated deaths (all causes) per month
cum_deaths <- vector()
cum_deaths <- cumsum(deaths)
data$cum_deaths <- cum_deaths #Cumulative deaths over time
data %>%
arrange(desc(total_deaths)) #Months arranged from higher to lower number of deaths
#Checking missing values:
colSums(is.na(data))
#Millor fer servir time_period però transformant la data amb xts() queda l'eix x amb dates al gràfic dinàmic
data_plot_1 <- data.frame(
time=data$time_period,
Zymotic=data$zymotic,
Injuries=data$injuries,
Other=data$other)
dygraph(data_plot_1, main="Death causes (absolute values)")
data_plot_2 <- data.frame(
time=data$time_period,
Zymotic=data$zymotic_rate,
Injuries=data$injuries_rate,
Other=data$other_rate)
dygraph(data_plot_2, main="Death causes (rates)")
data_plot_3 <- data.frame(
time=data$time_period,
Army=data$avg_size_army)
dygraph(data_plot_3, main="Average size of the army")
data_plot_4 <- data.frame(
time=data$time_period,
Accumulated_deaths=cum_deaths) #No m'acaba d'agradar el nom de la variable top-right. Millor data amb xts()?
dygraph(data_plot_4, main="Accumulated number of deaths")
deaths
#Univariant linear regresion between all deaths and the average size of army:
mod1 <- lm(avg_size_army ~ total_deaths, data=data)
summary(mod1)
#Analysis of correlation for all deaths:
cor(data$avg_size_army, data$total_deaths)
#És deaths i totaldeaths el mateix?
tra_death <- data.frame(y=data$total_deaths[2:L], lag1=data$total_deaths[1:(L-1)])
reg1 <- lm(y ~ lag1, data=tra_death) #Regressió morts avui en funció de les morts d'ahir
summary(reg1)
reg2 <- lm(data$total_deaths ~ data$time_period, data=data)
summary(reg2) #No significació del time period sobre total deaths
#Accuracy de reg1 per fer prediccions (he provat de fer la del número de morts basant-me només en un lag d'aquesta mateixa variable per provar de fer-ne alguna)
train_data <- subset(data, time_period<=round(0.7*L)) #70% training data
test_data <- subset(data, time_period>round(0.7*L)) #30% test/validation data
training1 <- data.frame(y=train_data$total_deaths, lag1=train_data$total_deaths)
model1 <- lm(y ~ lag1, data=training1)
y.hat1 <- predict(model1, data=test_data)
error1 <- abs(y.hat1 - test_data$total_deaths)
rmse1 <- sqrt((sum(error1)**2)/nrow(test_data))
#Fatal performance, tampoc sé si té gaire sentit predir el número de morts futures a partir de les del dia anterior, ens caldria algo amb més chicha
qqnorm(residual.values, col="blue")
qqline(residual.values)
#A la vista del gràfic, no s’observa cap patró especial, de manera que tant la homocedasticitat com la linealitat resulten hipòtesis raonables.
#D’altra banda, el Q_Q plot mostra que les dades no s’ajusten bé a una normal.
reg3 <- glm(formula=data$avg_size_army~data$injuries, data=data)
summary(reg3)
reg3 <- lm(formula=data$avg_size_army~data$injuries, data=data)
summary(reg3)
reg3 <- glm(formula=data$avg_size_army~data$injuries, data=data)
summary(reg3)
#Multivariant linear regresion between all deaths (segregated) and the average size of army:
mod2 <- lm(avg_size_army ~ data$zymotic, data=data)
summary(mod2)
#Multivariant linear regresion between all deaths (segregated) and the average size of army:
mod2 <- lm(avg_size_army ~ data$zymotic+data$injuries+data$other, data=data)
summary(mod2)
reg3 <- lm(formula=data$avg_size_army~data$injuries, data=data)
summary(reg3)
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
rm=ls()
?rm
#Libraries used across the whole project:     (haurem de revisar quins no fem servir al final i treure'ls)
library(readxl)
library(tidyverse)
library(tidyverse)
library(gt)
library(dygraphs)
library(xts)
library(lmtest)
library(sandwich)
library(ResourceSelection)
library(pROC)
#Importing dataset:
data <- read_excel("../nightingale-competition/datos_florence.xlsx", skip=1)
#Making everything more readable and column names more manageable:
colnames(data)[1] <- "month"
colnames(data)[2] <- "avg_size_army"
colnames(data)[3] <- "zymotic"
colnames(data)[4] <- "injuries"
colnames(data)[5] <- "other"
colnames(data)[6] <- "zymotic_rate"
colnames(data)[7] <- "injuries_rate"
colnames(data)[8] <- "other_rate"
#Making everything more readable and column names more manageable:
colnames(data)[1] <- "month"
colnames(data)[2] <- "avg_size_army"
colnames(data)[3] <- "zymotic"
colnames(data)[4] <- "injuries"
colnames(data)[5] <- "other"
colnames(data)[6] <- "zymotic_rate"
colnames(data)[7] <- "injuries_rate"
colnames(data)[8] <- "other_rate"
L <- nrow(data)
time_period <- seq(0,(L-1)) #Podríem passar-ho de 1 a L
data$time_period <- time_period
#data <- as.data.frame(data)
time_vars <- select(data, month, time_period)
time_vars %>%
gt() %>%
tab_header(title = md("**Time periods**"), subtitle = md("Equivalence between both variables"))
# Estic en procés de fer-la més maca jajaja
rm(list=ls())
L <- nrow(data)
time_period <- seq(0,(L-1)) #Podríem passar-ho de 1 a L
rm(list=ls()) #Per esborrar tot el que estigui carregat d'algun environment que haguem tingut anteriorment (podem esborrar-ho un cop ho entreguem però jo sempre ho deixo just in case)
#Libraries used across the whole project:     (haurem de revisar quins no fem servir al final i treure'ls)
library(readxl)
library(tidyverse)
library(gt)
library(dygraphs)
library(xts)
library(lmtest)
library(sandwich)
library(ResourceSelection)
library(pROC)
#Importing dataset:
data <- read_excel("../nightingale-competition/datos_florence.xlsx", skip=1)
#Making everything more readable and column names more manageable:
colnames(data)[1] <- "month"
colnames(data)[2] <- "avg_size_army"
colnames(data)[3] <- "zymotic"
colnames(data)[4] <- "injuries"
colnames(data)[5] <- "other"
colnames(data)[6] <- "zymotic_rate"
colnames(data)[7] <- "injuries_rate"
colnames(data)[8] <- "other_rate"
#Basic information:
head(data)
#Creating a numeric variable to account for time period:
L <- nrow(data)
time_period <- seq(0,(L-1)) #Podríem passar-ho de 1 a L
data$time_period <- time_period
#data <- as.data.frame(data)
time_vars <- select(data, month, time_period)
time_vars %>%
gt() %>%
tab_header(title = md("**Time periods**"), subtitle = md("Equivalence between both variables"))
# Estic en procés de fer-la més maca jajaja
#Adding new variables to the dataset:
deaths <- vector()
for(i in 1:L){
deaths[i] <- data$zymotic[i] + data$injuries[i] + data$other[i]
}
data$total_deaths <- deaths #Agreggated deaths (all causes) per month
cum_deaths <- vector()
cum_deaths <- cumsum(deaths)
data$cum_deaths <- cum_deaths #Cumulative deaths over time
#Creating a numeric variable to account for time period:
L <- nrow(data)
time_period <- seq(0,(L-1)) #Podríem passar-ho de 1 a L
data$time_period <- time_period
#data <- as.data.frame(data)
time_vars <- select(data, month, time_period)
time_vars %>%
gt() %>%
tab_header(title = md("**Time periods**"), subtitle = md("Equivalence between both variables"))
# Estic en procés de fer-la més maca jajaja
str(data)
#Adding new variables to the dataset:
deaths <- vector()
for(i in 1:L){
deaths[i] <- data$zymotic[i] + data$injuries[i] + data$other[i]
}
data$total_deaths <- deaths #Agreggated deaths (all causes) per month
cum_deaths <- vector()
cum_deaths <- cumsum(deaths)
data$cum_deaths <- cum_deaths #Cumulative deaths over time
data %>%
arrange(desc(total_deaths)) #Months arranged from higher to lower number of deaths
data %>%
arrange(desc(data$total_deaths))[1,9] #Months arranged from higher to lower number of deaths
data %>%
arrange(desc(data$total_deaths)) #Months arranged from higher to lower number of deaths
#Basic information:
head(data)
?head
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
rm(list=ls()) #Per esborrar tot el que estigui carregat d'algun environment que haguem tingut anteriorment (podem esborrar-ho un cop ho entreguem però jo sempre ho deixo just in case)
#Libraries used across the whole project:     (haurem de revisar quins no fem servir al final i treure'ls)
library(readxl)
library(tidyverse)
library(gt)
library(dygraphs)
library(formattable)
library(xts)
library(lmtest)
library(tseries)
library(sandwich)
library(ResourceSelection)
library(pROC)
#Importing dataset:
data <- read_excel("../nightingale-competition/datos_florence.xlsx", skip=1)
#Making everything more readable and column names more manageable:
colnames(data)[1] <- "month"
colnames(data)[2] <- "avg_size_army"
colnames(data)[3] <- "zymotic"
colnames(data)[4] <- "injuries"
colnames(data)[5] <- "other"
colnames(data)[6] <- "zymotic_rate"
colnames(data)[7] <- "injuries_rate"
colnames(data)[8] <- "other_rate"
#Creating a numeric variable to account for time period:
L <- nrow(data)
time_period <- seq(0,(L-1)) #Podríem passar-ho de 1 a L
data$time_period <- time_period
data <- as.data.frame(data)
#Visualizing in a colorful data table the changes performed:
df <- data.frame(
month = c("Apr 1854", "May 1854", "Jun 1854", "Jul 1854", "Aug 1854", "Sep 1854", "Oct 1854", "Nov 1854", "Dec 1854", "Jan              1855", "Feb 1855", "Mar 1855", "Apr 1855", "May 1855", "Jun 1855", "Jul 1855", "Aug 1855", "Sep 1855", "Oct 1855", "Nov 1855", "Dec 1855", "Jan 1856", "Feb 1856", "Mar 1856"),
time_period = 0:23)
formattable(df, list(area(col = month:time_period) ~ color_tile("lightpink", "lightblue")))
#He intentat fer una taula una mica més colorida. No he trobar com posar-li títol. Per cert, per fer visualitzacions amb R aquest package que he trobat em sembla super cool, sobretot si les variables són numèriques! hehe Podem jugar amb els colors també.
#time_vars <- select(data, month, time_period)
#time_vars %>%
#gt() %>%
#tab_header(title = md("**Time periods**"), subtitle = md("Equivalence between both variables"))
#He intentat fer-la més maca però el meu coneixement de taules és limitat. Trobo que queda potser una mica estreta però altres dissenys tampoc m'han acabat de fer el pes.
formattable(df, list(area(col = month:time_period) ~ color_tile("lightpink", "lightblue")))
#Adding new variables to the dataset:
deaths <- vector()
for(i in 1:L){
deaths[i] <- data$zymotic[i] + data$injuries[i] + data$other[i]
}
data$total_deaths <- deaths #Agreggated deaths (all causes) per month
cum_deaths <- vector()
cum_deaths <- cumsum(deaths)
data$cum_deaths <- cum_deaths #Cumulative deaths over time
deaths_evol <- select(data, month, total_deaths, time_period)
ordered_deaths <- deaths_evol %>%
arrange(desc(deaths_evol$total_deaths)) #Months arranged from higher to lower number of deaths
#Visualizing in a colorful data table the changes performed:
df2 <- data.frame(
month = c("Apr 1854", "May 1854", "Jun 1854", "Jul 1854", "Aug 1854", "Sep 1854", "Oct 1854", "Nov 1854", "Dec 1854", "Jan              1855", "Feb 1855", "Mar 1855", "Apr 1855", "May 1855", "Jun 1855", "Jul 1855", "Aug 1855", "Sep 1855", "Oct 1855", "Nov 1855", "Dec 1855", "Jan 1856", "Feb 1856", "Mar 1856"),
total_deaths = accounting(c(3168, 2523, 1970, 1409, 1237, 1042, 939, 859, 763, 672, 594, 582, 549, 485, 382, 243, 199, 137, 92, 50, 43, 21, 17, 6), format = "d"),
time_period = 0:23)
formattable(df2, list(
month = color_tile("transparent", "lightpink"),
total_deaths = color_bar("lightgreen")))
#He tornat a provar amb aquesta taula hehe, però again sense títol.
#ordered_deaths %>%
#gt() %>%
#tab_header(title = md("**Total deaths by month**"), subtitle = md("Data sorted in descending order"))
#Again, no sé fer la taula més mona jajajaja
#Checking outliers:
par(mfrow=c(1,3))
#Checking outliers:
par(mfrow=c(1,3))
boxplot(data$injuries, col="lightgoldenrod", main="Deaths by injuries")
boxplot(data$zymotic, col="mistyrose", main="Deaths by zymotic disease")
boxplot(data$other, col="powderblue", main="Deaths by other causes")
#Checking outliers:
par(mfrow=c(1,3)) #Amb això es veuen tots tres boxplots alhora ueeee
boxplot(data$injuries, col="lightgoldenrod", main="Deaths by injuries")
boxplot(data$zymotic, col="mistyrose", main="Deaths by zymotic disease")
boxplot(data$other, col="powderblue", main="Deaths by other causes")
# Compute percentages with dplyr
library(dplyr)
data <- data  %>%
group_by(data$time_period, data$total_deaths) %>%
summarise(n = sum(value)) %>%
mutate(percentage = n / sum(n))
# Compute percentages with dplyr
data <- data  %>%
group_by(data$time_period, data$total_deaths) %>%
summarise(n = sum(value)) %>%
mutate(percentage = n / sum(n))
