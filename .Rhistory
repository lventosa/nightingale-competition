library(xts) #Millor fer servir time_period però transformant la data amb xts() queda l'eix x amb dates al gràfic dinàmic
library(ggplot2)
data_plot_1 <- data.frame(
time=data$time_period,
Zymotic=data$zymotic,
Injuries=data$injuries,
Other=data$other)
dygraph(data_plot_1, main="Death causes (absolute values)")
data_plot_2 <- data.frame(
time=data$time_period,
Zymotic=data$zymotic_rate,
Injuries=data$injuries_rate,
Other=data$other_rate)
dygraph(data_plot_2, main="Death causes (rates)")
data_plot_3 <- data.frame(
time=data$time_period,
Army=data$avg_size_army)
dygraph(data_plot_3, main="Average size of the army")
#Aggregated deaths
deaths <- vector()
for(i in 1:L){
deaths[i] <- data$zymotic[i] + data$injuries[i] + data$other[i]
}
data$total_deaths <- deaths #Morts totals en cada mes
data$total_deaths
deaths
deaths
data$total_deaths
#Cumulative deaths
cum_deaths <- vector()
cum_deaths <- cumsum(deaths)
data$cum_deaths <- cum_deaths #Cumulative deaths
data_plot_4 <- data.frame(
time=data$time_period,
Accumulated_deaths=cum_deaths) #No m'acaba d'agradar el nom de la variable top-right. Millor data amb xts()?
dygraph(data_plot_4, main="Accumulated number of deaths")
corr1
# Diagnosi dels models:
residuals.values <- rstandard(reg1)
adjusted.values <- fitted(reg1)
plot(adjusted.values, residuals.values)
qqnorm(residual.values)
# Diagnosi dels models:
residual.values <- rstandard(reg1)
adjusted.values <- fitted(reg1)
plot(adjusted.values, residual.values)
qqnorm(residual.values)
qqline(residual.values)
exp(coefficients(reg1))
exp(confint(reg1))
reg1.2 <- glm(formula=y ~ lag1, data=tra_death, family=binomial)
reg1.2 <- glm(formula=y ~ lag1, data=data, family=binomial)
data
reg3 <- glm(formula=avg_size_army~injuries, data=data, family=binomial)
avg_size_army
reg3 <- glm(formula=data$avg_size_army~data$injuries, data=data, family=binomial)
reg3 <- glm(formula=data$avg_size_army~data$injuries, data=data)
summary(reg3)
exp(coefficients(reg3))
exp(confint(reg3))
data
reg4 <- glm(formula=data$avg_size_army~data$zymotic, data=data)
summary(reg3)
reg4 <- glm(formula=data$avg_size_army~data$zymotic, data=data)
summary(reg4)
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE) #Escrivint en aquesta línia el que està entre parèntesis, aquestes opcions es converteixen en globals per tot els blocs de codi del document. Les deixo aquí i les esborro individualment de cada bloc perquè quedi més net
#He fet knit en html de tot el document per veure com anava quedant i anar tocant coses segons com anem veient
# Nice gràcies, no ho sabia <3 :)
sapply(data, class) #Per no repetir-nos amb la funció anterior podem eliminar eliminar str() i deixar sapply() que queda més net jajaja
#Dimensions of our dataset
dim(data)
#Libraries used across the whole project:     (haurem de revisar quins no fem servir al final i treure'ls)
library(readxl)
library(tidyverse)
library(viridis)
library(dygraphs)
library(xts)
library(lmtest)
library(ResourceSelection)
library(pROC)
#library(kableExtra)
#library(ggpubr)
#library(DescTools)
#Importing dataset:
data <- read_excel("../nightingale-competition/datos_florence.xlsx", skip=1)
#Basic information:
head(data)
#Dimensions of the dataset:
dim(data)
#Variables:
sapply(data, class)
summary(data)
#Creating a numeric variable to account for time period:
L <- nrow(data)
time_period <- seq(0,(L-1)) #Podríem passar-ho de 1 a L
data$time_period <- time_period
data <- as.data.frame(data)
#Making everything more readable and column names more manageable:
colnames(data)[1] <- "month"
colnames(data)[2] <- "avg_size_army"
colnames(data)[3] <- "zymotic"
colnames(data)[4] <- "injuries"
colnames(data)[5] <- "other"
colnames(data)[6] <- "zymotic_rate"
colnames(data)[7] <- "injuries_rate"
colnames(data)[8] <- "other_rate"
#Adding new variables to the dataset:
deaths <- vector()
for(i in 1:L){
deaths[i] <- data$zymotic[i] + data$injuries[i] + data$other[i]
}
data$total_deaths <- deaths #Agreggated deaths (all causes) per month
cum_deaths <- vector()
cum_deaths <- cumsum(deaths)
data$cum_deaths <- cum_deaths #Cumulative deaths over time
boxplot(injuries~avg_size_army, data, main="Injuries vs Avg Size of Army", xlab="Avg size of army", ylab="Deaths by injury")
boxplot(zymotic~avg_size_army, data, main="Zymotic vs Avg Size of Army", xlab="Avg size of army", ylab="Deaths by zymotic disease")
boxplot(other~avg_size_army, data, main="Other vs Avg Size of Army", xlab="Avg size of army", ylab="Deaths by other causes")
#Els boxplots se'm veuen com només ratlles horitzontals. Probablement sigui perquè avg_size_army no categoritza lo suficient. Millor així?:
boxplot(data$injuries, col="lightgoldenrod", main="Deaths by injuries")
boxplot(data$zymotic, col="mistyrose", main="Deaths by zymotic disease")
boxplot(data$other, col="powderblue", main="Deaths by other causes")
#He intentat encabir les tres caixes en un sol plot però no he aconseguit que quedessin quadrades les labels a l'eix horitzontal amb el nom de cada variable
#Millor fer servir time_period però transformant la data amb xts() queda l'eix x amb dates al gràfic dinàmic
data_plot_1 <- data.frame(
time=data$time_period,
Zymotic=data$zymotic,
Injuries=data$injuries,
Other=data$other)
dygraph(data_plot_1, main="Death causes (absolute values)")
data_plot_2 <- data.frame(
time=data$time_period,
Zymotic=data$zymotic_rate,
Injuries=data$injuries_rate,
Other=data$other_rate)
dygraph(data_plot_2, main="Death causes (rates)")
data_plot_3 <- data.frame(
time=data$time_period,
Army=data$avg_size_army)
dygraph(data_plot_3, main="Average size of the army")
data_plot_4 <- data.frame(
time=data$time_period,
Accumulated_deaths=cum_deaths) #No m'acaba d'agradar el nom de la variable top-right. Millor data amb xts()?
dygraph(data_plot_4, main="Accumulated number of deaths")
ggplot(aes(x=avg_size_army, y=injuries), data=subset(pf, !is.na(month))) +
geom_line(aes(color=month), stat="summary", fun.y=median)
time_period
data$time_period
data
deaths
ggplot(aes(x=month, y=injuries), data=subset(pf, !is.na(deaths))) +
geom_line(aes(color=deaths), stat="summary", fun.y=median)
deaths
ggplot(aes(x=month, y=injuries), data=subset(pf, !is.na(month))) +
geom_line(aes(color=month), stat="summary", fun.y=median)
# Correlations (mirar com ho deixem)
cor(data$avg_size_army, data$zymotic)
cor(data$avg_size_army, data$injuries)
cor(data$avg_size_army, data$other)
cor(data$avg_size_army, data$total_deaths)
str(data)
#Adding new variables to the dataset:
deaths <- vector()
for(i in 1:L){
deaths[i] <- data$zymotic[i] + data$injuries[i] + data$other[i]
}
data$total_deaths <- deaths #Agreggated deaths (all causes) per month
cum_deaths <- vector()
cum_deaths <- cumsum(deaths)
data$cum_deaths <- cum_deaths #Cumulative deaths over time
str(data)
data %>%
arrange(desc(total_deaths)) #Mesos ordenats de més morts totals a menys
data %>%
arrange(desc(total_deaths)) #Months arranged from higher to lower number of deaths
#Millor fer servir time_period però transformant la data amb xts() queda l'eix x amb dates al gràfic dinàmic
data_plot_1 <- data.frame(
time=data$time_period,
Zymotic=data$zymotic,
Injuries=data$injuries,
Other=data$other)
dygraph(data_plot_1, main="Death causes (absolute values)")
data_plot_2 <- data.frame(
time=data$time_period,
Zymotic=data$zymotic_rate,
Injuries=data$injuries_rate,
Other=data$other_rate)
dygraph(data_plot_2, main="Death causes (rates)")
data_plot_3 <- data.frame(
time=data$time_period,
Army=data$avg_size_army)
dygraph(data_plot_3, main="Average size of the army")
# Correlations (mirar com ho deixem)
cor(data$avg_size_army, data$zymotic)
cor(data$avg_size_army, data$injuries)
cor(data$avg_size_army, data$other)
cor(data$avg_size_army, data$total_deaths)
tra_death <- data.frame(y=data$total_deaths[2:L], lag1=data$total_deaths[1:(L-1)])
reg1 <- lm(y ~ lag1, data=tra_death) #Regressió morts avui en funció de les morts d'ahir
summary(reg1)
# Correlations (mirar com ho deixem)
cor(data$avg_size_army, data$zymotic)
cor(data$avg_size_army, data$injuries)
cor(data$avg_size_army, data$other)
cor(data$avg_size_army, data$total_deaths)
tra_death <- data.frame(y=data$total_deaths[2:L], lag1=data$total_deaths[1:(L-1)])
reg1 <- lm(y ~ lag1, data=tra_death) #Regressió morts avui en funció de les morts d'ahir
summary(reg1)
# Correlations (mirar com ho deixem)
cor(data$avg_size_army, data$zymotic)
cor(data$avg_size_army, data$injuries)
cor(data$avg_size_army, data$other)
cor(data$avg_size_army, data$total_deaths)
tra_death <- data.frame(y=data$total_deaths[2:L], lag1=data$total_deaths[1:(L-1)])
reg1 <- lm(y ~ lag1, data=tra_death) #Regressió morts avui en funció de les morts d'ahir
summary(reg1)
mod1 <- lm(deaths ~ avg_size_army, data=data) #Regressió morts avui en funció de les morts d'ahir
summary(mod1)
#Univariant linear regresion between all deaths and the average size of army:
mod1 <- lm(avg_size_army ~ deaths, data=data)
summary(mod1)
data$zymotic
zymotic
#Multivariant linear regresion between all deaths (segregated) and the average size of army:
mod2 <- lm(avg_size_army ~ data$zymotic+data$injuries+data$other, data=data)
summary(mod2)
data$total_deaths
#Analysis of correlation for all deaths:
cor(data$avg_size_army, data$total_deaths)
#És deaths i totaldeaths el mateix?
#Multivariant linear regresion between all deaths (segregated) and the average size of army:
mod2 <- lm(avg_size_army ~ data$zymotic+data$injuries+data$other, data=data)
summary(mod2)
#Analysis of correlations per different types of deaths segregated: (mirar com ho deixem)
cor(data$avg_size_army, data$zymotic)
cor(data$avg_size_army, data$injuries)
cor(data$avg_size_army, data$other)
tra_death <- data.frame(y=data$total_deaths[2:L], lag1=data$total_deaths[1:(L-1)])
reg1 <- lm(y ~ lag1, data=tra_death) #Regressió morts avui en funció de les morts d'ahir
summary(reg1)
reg2 <- lm(data$total_deaths ~ data$time_period, data=data)
summary(reg2) #No significació del time period sobre total deaths
#Accuracy de reg1 per fer prediccions (he provat de fer la del número de morts basant-me només en un lag d'aquesta mateixa variable per provar de fer-ne alguna)
train_data <- subset(data, time_period<=round(0.7*L)) #70% training data
test_data <- subset(data, time_period>round(0.7*L)) #30% test/validation data
training1 <- data.frame(y=train_data$total_deaths, lag1=train_data$total_deaths)
model1 <- lm(y ~ lag1, data=training1)
y.hat1 <- predict(model1, data=test_data)
error1 <- abs(y.hat1 - test_data$total_deaths)
rmse1 <- sqrt((sum(error1)**2)/nrow(test_data))
#Fatal performance, tampoc sé si té gaire sentit predir el número de morts futures a partir de les del dia anterior, ens caldria algo amb més chicha
# Diagnosi dels models:
residual.values <- rstandard(reg1)
adjusted.values <- fitted(reg1)
plot(adjusted.values, residual.values, main="Residual plot reg1 (canviar nom maybe)", ylab="Residual Values", xlab="Adjusted Values", col="lightsalmon3", abline(0, 0), pch=19)
#He afegit colors al gràfic, poden ser aquests o es poden canviar. Podríem utilitzar els mateixos colors per tots els plots d'un mateix tipus
qqnorm(residual.values) #posar-li colors també
qqline(residual.values)
#A la vista del gràfic, no s’observa cap patró especial, de manera que tant la homocedasticitat com la linealitat resulten hipòtesis raonables.
#D’altra banda, el Q_Q plot mostra que les dades no s’ajusten bé a una normal.
reg3 <- glm(formula=data$avg_size_army~data$injuries, data=data)
summary(reg3)
exp(coefficients(reg3))
exp(confint(reg3))
reg4 <- glm(formula=data$avg_size_army~data$zymotic, data=data)
summary(reg4)
# Diagnosi dels models:
residual.values <- rstandard(reg1)
adjusted.values <- fitted(reg1)
plot(adjusted.values, residual.values, main="Residual plot reg1 (canviar nom maybe)", ylab="Residual Values", xlab="Adjusted Values", col="lightsalmon3", abline(0, 0), pch=19)
#He afegit colors al gràfic, poden ser aquests o es poden canviar. Podríem utilitzar els mateixos colors per tots els plots d'un mateix tipus
qqnorm(residual.values) #posar-li colors també
qqline(residual.values)
ylab="Residual Values", xlab="Adjusted Values", col="lightsalmon3", abline(0, 0), pch=19)
qqnorm(residual.values) #posar-li colors també
qqline(residual.values)
with(plotData, {
plot(x, y, col = ifelse(id == 1, "red", "blue"))
abline(int, slope)
})
qqnorm(residual.values) #posar-li colors també
qqline(residual.values)
plotData <- qqPlot(myData$x, "normal",confbounds = FALSE, col = sample(colors(), nrow(myData)))
qqnorm(residual.values)
qqline(residual.values)
qqnorm(d1$V1[is.finite(d1$V1)], col=colorvector)
qqnorm(residual.values, col=colorvector)
qqnorm(residual.values, col="lightsalmon3")
qqline(residual.values)
qqnorm(d1$V1[is.finite(d1$V1)], col=colorvector)
qqnorm(residual.values, col="blue")
qqline(residual.values)
qqnorm(d1$V1[is.finite(d1$V1)], col=colorvector)
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
#Creating a numeric variable to account for time period:
L <- nrow(data)
time_period <- seq(0,(L-1)) #Podríem passar-ho de 1 a L
data$time_period <- time_period
data <- as.data.frame(data)
#Making everything more readable and column names more manageable:
colnames(data)[1] <- "month"
colnames(data)[2] <- "avg_size_army"
colnames(data)[3] <- "zymotic"
colnames(data)[4] <- "injuries"
colnames(data)[5] <- "other"
colnames(data)[6] <- "zymotic_rate"
colnames(data)[7] <- "injuries_rate"
colnames(data)[8] <- "other_rate"
data$time_period
#Creating a numeric variable to account for time period:
L <- nrow(data)
time_period <- seq(0,(L-1)) #Podríem passar-ho de 1 a L
data$time_period <- time_period
data <- as.data.frame(data)
#Making everything more readable and column names more manageable:
colnames(data)[1] <- "month"
colnames(data)[2] <- "avg_size_army"
colnames(data)[3] <- "zymotic"
colnames(data)[4] <- "injuries"
colnames(data)[5] <- "other"
colnames(data)[6] <- "zymotic_rate"
colnames(data)[7] <- "injuries_rate"
colnames(data)[8] <- "other_rate"
data
#Making everything more readable and column names more manageable:
colnames(data)[1] <- "month"
colnames(data)[2] <- "avg_size_army"
colnames(data)[3] <- "zymotic"
colnames(data)[4] <- "injuries"
colnames(data)[5] <- "other"
colnames(data)[6] <- "zymotic_rate"
colnames(data)[7] <- "injuries_rate"
colnames(data)[8] <- "other_rate"
#Adding new variables to the dataset:
deaths <- vector()
for(i in 1:L){
deaths[i] <- data$zymotic[i] + data$injuries[i] + data$other[i]
}
data$total_deaths <- deaths #Agreggated deaths (all causes) per month
cum_deaths <- vector()
cum_deaths <- cumsum(deaths)
data$cum_deaths <- cum_deaths #Cumulative deaths over time
data %>%
arrange(desc(total_deaths)) #Months arranged from higher to lower number of deaths
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
#Libraries used across the whole project:     (haurem de revisar quins no fem servir al final i treure'ls)
library(readxl)
library(tidyverse)
library(viridis)
library(dygraphs)
library(xts)
library(lmtest)
library(ResourceSelection)
library(pROC)
#Importing dataset:
data <- read_excel("../nightingale-competition/datos_florence.xlsx", skip=1)
#Basic information:
head(data)
#Dimensions of the dataset:
dim(data)
#Variables:
sapply(data, class)
summary(data)
data %>%
arrange(desc(total_deaths)) #Months arranged from higher to lower number of deaths
data$total_deaths
total_deaths
#Making everything more readable and column names more manageable:
colnames(data)[1] <- "month"
colnames(data)[2] <- "avg_size_army"
colnames(data)[3] <- "zymotic"
colnames(data)[4] <- "injuries"
colnames(data)[5] <- "other"
colnames(data)[6] <- "zymotic_rate"
colnames(data)[7] <- "injuries_rate"
colnames(data)[8] <- "other_rate"
#Adding new variables to the dataset:
deaths <- vector()
for(i in 1:L){
deaths[i] <- data$zymotic[i] + data$injuries[i] + data$other[i]
}
data$total_deaths <- deaths #Agreggated deaths (all causes) per month
cum_deaths <- vector()
cum_deaths <- cumsum(deaths)
data$cum_deaths <- cum_deaths #Cumulative deaths over time
data %>%
arrange(desc(total_deaths)) #Months arranged from higher to lower number of deaths
#Checking missing values:
colSums(is.na(data))
#Checking outliers:
boxplot(data$injuries, col="lightgoldenrod", main="Deaths by injuries")
boxplot(data$zymotic, col="mistyrose", main="Deaths by zymotic disease")
boxplot(data$other, col="powderblue", main="Deaths by other causes")
#He intentat encabir les tres caixes en un sol plot però no he aconseguit que quedessin quadrades les labels a l'eix horitzontal amb el nom de cada variable
#Millor fer servir time_period però transformant la data amb xts() queda l'eix x amb dates al gràfic dinàmic
data_plot_1 <- data.frame(
time=data$time_period,
Zymotic=data$zymotic,
Injuries=data$injuries,
Other=data$other)
#Millor fer servir time_period però transformant la data amb xts() queda l'eix x amb dates al gràfic dinàmic
data_plot_1 <- data.frame(
time=data$time_period,
Zymotic=data$zymotic,
Injuries=data$injuries,
Other=data$other)
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
#Libraries used across the whole project:     (haurem de revisar quins no fem servir al final i treure'ls)
library(readxl)
library(tidyverse)
library(viridis)
library(dygraphs)
library(xts)
library(lmtest)
library(ResourceSelection)
library(pROC)
#Importing dataset:
data <- read_excel("../nightingale-competition/datos_florence.xlsx", skip=1)
#Basic information:
head(data)
#Dimensions of the dataset:
dim(data)
#Variables:
sapply(data, class)
summary(data)
#Creating a numeric variable to account for time period:
L <- nrow(data)
time_period <- seq(0,(L-1)) #Podríem passar-ho de 1 a L
data$time_period <- time_period
data <- as.data.frame(data)
#Making everything more readable and column names more manageable:
colnames(data)[1] <- "month"
colnames(data)[2] <- "avg_size_army"
colnames(data)[3] <- "zymotic"
colnames(data)[4] <- "injuries"
colnames(data)[5] <- "other"
colnames(data)[6] <- "zymotic_rate"
colnames(data)[7] <- "injuries_rate"
colnames(data)[8] <- "other_rate"
#Adding new variables to the dataset:
deaths <- vector()
for(i in 1:L){
deaths[i] <- data$zymotic[i] + data$injuries[i] + data$other[i]
}
data$total_deaths <- deaths #Agreggated deaths (all causes) per month
cum_deaths <- vector()
cum_deaths <- cumsum(deaths)
data$cum_deaths <- cum_deaths #Cumulative deaths over time
data %>%
arrange(desc(total_deaths)) #Months arranged from higher to lower number of deaths
#Checking missing values:
colSums(is.na(data))
#Millor fer servir time_period però transformant la data amb xts() queda l'eix x amb dates al gràfic dinàmic
data_plot_1 <- data.frame(
time=data$time_period,
Zymotic=data$zymotic,
Injuries=data$injuries,
Other=data$other)
dygraph(data_plot_1, main="Death causes (absolute values)")
data_plot_2 <- data.frame(
time=data$time_period,
Zymotic=data$zymotic_rate,
Injuries=data$injuries_rate,
Other=data$other_rate)
dygraph(data_plot_2, main="Death causes (rates)")
data_plot_3 <- data.frame(
time=data$time_period,
Army=data$avg_size_army)
dygraph(data_plot_3, main="Average size of the army")
data_plot_4 <- data.frame(
time=data$time_period,
Accumulated_deaths=cum_deaths) #No m'acaba d'agradar el nom de la variable top-right. Millor data amb xts()?
dygraph(data_plot_4, main="Accumulated number of deaths")
deaths
#Univariant linear regresion between all deaths and the average size of army:
mod1 <- lm(avg_size_army ~ total_deaths, data=data)
summary(mod1)
#Analysis of correlation for all deaths:
cor(data$avg_size_army, data$total_deaths)
#És deaths i totaldeaths el mateix?
tra_death <- data.frame(y=data$total_deaths[2:L], lag1=data$total_deaths[1:(L-1)])
reg1 <- lm(y ~ lag1, data=tra_death) #Regressió morts avui en funció de les morts d'ahir
summary(reg1)
reg2 <- lm(data$total_deaths ~ data$time_period, data=data)
summary(reg2) #No significació del time period sobre total deaths
#Accuracy de reg1 per fer prediccions (he provat de fer la del número de morts basant-me només en un lag d'aquesta mateixa variable per provar de fer-ne alguna)
train_data <- subset(data, time_period<=round(0.7*L)) #70% training data
test_data <- subset(data, time_period>round(0.7*L)) #30% test/validation data
training1 <- data.frame(y=train_data$total_deaths, lag1=train_data$total_deaths)
model1 <- lm(y ~ lag1, data=training1)
y.hat1 <- predict(model1, data=test_data)
error1 <- abs(y.hat1 - test_data$total_deaths)
rmse1 <- sqrt((sum(error1)**2)/nrow(test_data))
#Fatal performance, tampoc sé si té gaire sentit predir el número de morts futures a partir de les del dia anterior, ens caldria algo amb més chicha
qqnorm(residual.values, col="blue")
qqline(residual.values)
#A la vista del gràfic, no s’observa cap patró especial, de manera que tant la homocedasticitat com la linealitat resulten hipòtesis raonables.
#D’altra banda, el Q_Q plot mostra que les dades no s’ajusten bé a una normal.
reg3 <- glm(formula=data$avg_size_army~data$injuries, data=data)
summary(reg3)
reg3 <- lm(formula=data$avg_size_army~data$injuries, data=data)
summary(reg3)
reg3 <- glm(formula=data$avg_size_army~data$injuries, data=data)
summary(reg3)
#Multivariant linear regresion between all deaths (segregated) and the average size of army:
mod2 <- lm(avg_size_army ~ data$zymotic, data=data)
summary(mod2)
#Multivariant linear regresion between all deaths (segregated) and the average size of army:
mod2 <- lm(avg_size_army ~ data$zymotic+data$injuries+data$other, data=data)
summary(mod2)
reg3 <- lm(formula=data$avg_size_army~data$injuries, data=data)
summary(reg3)
